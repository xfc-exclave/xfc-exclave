<!DOCTYPE html><html lang="ja"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="チンモクのブログ" href="https://www.chinmoku.cc/rss.xml"><link rel="alternate" type="application/atom+xml" title="チンモクのブログ" href="https://www.chinmoku.cc/atom.xml"><link rel="alternate" type="application/json" title="チンモクのブログ" href="https://www.chinmoku.cc/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="Linux,Docker"><link rel="canonical" href="https://www.chinmoku.cc/computer-science/java-learning-path/5-framework/docker-tutorial/"><title>给，你要的 Docker 详细教程 - 架构篇 - JAVA 学习路线 - 计算机科学 | Chinmoku = チンモクのブログ = 露の世は　露の世ながら　さりながら</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">给，你要的 Docker 详细教程</h1><div class="meta"><span class="item" title="作成日：2021-08-10 21:40:36"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">投稿日</span> <time itemprop="dateCreated datePublished" datetime="2021-08-10T21:40:36+08:00">2021-08-10</time> </span><span class="item" title="単語数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">単語数</span> <span>19k</span> <span class="text">単語</span> </span><span class="item" title="読書の時間"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">読書の時間</span> <span>17 分</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="ナビゲーションバーの切り替え"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Chinmoku</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="https://img.xfc-exclave.com/2021/08/9a06207ceb0ebb00acdda04836b963de1628336179.png"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">ホーム</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/" itemprop="item" rel="index" title="カテゴリ 计算机科学"><span itemprop="name">计算机科学</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/java-learning-path/" itemprop="item" rel="index" title="カテゴリ JAVA 学习路线"><span itemprop="name">JAVA 学习路线</span></a><meta itemprop="position" content="2"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/java-learning-path/%E6%9E%B6%E6%9E%84%E7%AF%87/" itemprop="item" rel="index" title="カテゴリ 架构篇"><span itemprop="name">架构篇</span></a><meta itemprop="position" content="3"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="ja"><link itemprop="mainEntityOfPage" href="https://www.chinmoku.cc/computer-science/java-learning-path/5-framework/docker-tutorial/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="チンモク"><meta itemprop="description" content="露の世は　露の世ながら　さりながら, 本站主要以 Java 开发总结文章为主，也会向技术周边进行适当的扩展。此外，偶尔会更新部分其他学习或感兴趣的内容，如语言学习、文本翻译、文艺创作等。"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="チンモクのブログ"></span><div class="body md" itemprop="articleBody"><div class="note info"><p>Docker 是一个用于开发、发布和运行应用程序的开放平台，它能够使您将引用程序与基础设施分离开来，以实现快速交付。使用 Docker，您可以使用与管理您的应用程序相同的方式管理您的基础设施。通过利用 Docker 快速发布、测试及部署代码的方法，您可以显著地减少编写代码和在生产环境中运行代码之间的延迟。</p></div><h3 id="docker-概述"><a class="anchor" href="#docker-概述">#</a> Docker 概述</h3><h4 id="docker-平台"><a class="anchor" href="#docker-平台">#</a> Docker 平台</h4><p>Docker 提供了在一个被称之为 <code>容器</code> 的松散隔离的环境中进行打包和运行程序的能力。这种隔离性和安全性使您能够在同一台给定的主机上同时运行多个容器。所有的容器都是轻量级的，并且包含了应用程序运行所需要的一切，因此您不需要再依赖于当前主机所安装的内容。</p><h4 id="docker-可以做什么"><a class="anchor" href="#docker-可以做什么">#</a> Docker 可以做什么</h4><ol><li><p>快速、一致的交付应用程序。</p><p>Docker 适合持续集成和持续交付（CI/CD）工作流。</p><p><img data-src="https://img.xfc-exclave.com/2021/08/34056f83461b2667fefe304d915170211628335468.png" alt="DevOps能力环"></p><blockquote><p>关于 <code>CI/CD</code> ：<span class="exturl" data-url="aHR0cHM6Ly93d3cucmVkaGF0LmNvbS96aC90b3BpY3MvZGV2b3BzL3doYXQtaXMtY2ktY2Q=">https://www.redhat.com/zh/topics/devops/what-is-ci-cd</span></p><p>关于 <code>DevOps</code> ：<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9kZXZvcHMvMjYxMzAyOQ==">https://baike.baidu.com/item/devops/2613029</span></p></blockquote></li><li><p>响应式部署和扩展。</p><p>Docker 基于容器的平台允许高度可移植的工作负载。Docker 容器可以在开发人员的本地笔记本电脑、数据中心的物理或虚拟机、云提供商或混合环境中运行。</p><p>Docker 的可移植性和轻量级特性还使动态管理工作负载、根据业务需求几乎实时地扩展或拆除应用程序和服务变得容易。</p></li><li><p>在相同的硬件环境上运行更多工作负载。</p><p>Docker 非常适合高密度环境以及需要以更少资源完成更多任务的中小型部署。</p></li></ol><blockquote><p>Docker 理念是将应用及依赖包打包到一个可移植的容器中，可发布到任意 Linux 发行版 Docker 引擎上。使用沙箱机制运行程序，程序之间相互隔离。</p></blockquote><h4 id="docker-体系结构"><a class="anchor" href="#docker-体系结构">#</a> Docker 体系结构</h4><p>Docker 使用 <code>客户端 - 服务器</code> 的架构模式， Docker 客户端与 Docker 守护进程进行对话，后者负责构建、运行和分发 Docker 容器的繁重工作。它们既可以在同一系统上运行，也可以远程建立连接。客户端和守护进程之间使用 <code>REST API</code> 、 UNIX 套接字或网络接口进行通信。 Docker 体系结构如下图所示：</p><p><img data-src="https://img.xfc-exclave.com/2021/08/b595b80b1dc39db2af4ffd6f0e8e8f551628335478.svg+xml" alt="Docker体系结构示意图"></p><h5 id="docker-守护进程"><a class="anchor" href="#docker-守护进程">#</a> Docker 守护进程</h5><p>Docker 守护进程（ <code>dockerd</code> ）侦听 Docker API 的请求并管理 Docker 对象，如镜像、容器、网络和卷。守护进程还可以与其他守护进程进行通信以管理 Docker 服务。</p><h5 id="docker-客户端"><a class="anchor" href="#docker-客户端">#</a> Docker 客户端</h5><p>Docker 客户端 ( <code>docker</code> ) 是许多 Docker 用户与 Docker 进行交互的主要方式。当用户发起 <code>docker run</code> 等命令时，客户端会使用 <code>Docker API</code> 将这些命令发送到 dockerd 并执行。一个 Docker 客户端可以与多个 dockerd 进行通信。</p><h5 id="docker-注册表"><a class="anchor" href="#docker-注册表">#</a> Docker 注册表</h5><p>Docker Hub 是 Docker 镜像的公共注册中心， Docker 默认配置是从 Docker Hub 上查找镜像，您也可以根据需要配置自己的私有注册表。</p><p>当使用 <code>docker pull</code> 或 <code>docker run</code> 命令时，您所需要的镜像将从配置的注册表中提取。当使用 <code>dcoker push</code> 命令时，您的镜像会被推送到您配置的注册表中。</p><blockquote><p>Docker 注册表工作原理与 Git 相似。</p></blockquote><h5 id="docker-对象"><a class="anchor" href="#docker-对象">#</a> Docker 对象</h5><ol><li><p>镜像（ <code>Image</code> ）</p><p>镜像是用于创建 Docker 容器指令的 <strong>只读模板</strong> 。通常，一个镜像会基于另一个镜像，例如，您可以构建一个基于 ubuntu 镜像的镜像，并安装 Apache Web 服务器和您的引用程序，以及您的应用程序所需要的相关环境和配置详细信息。</p><p>在构建自己的镜像时，您需要使用简单的语法创建一个 <code>Dockerfile</code> ，用于定义创建和运行镜像所需要的步骤。Dockerfile 中的每条指令都会在镜像中创建一个层（ <code>layer</code> ）。当对镜像进行重建时，只会重建被更改的层，而非所有。这种虚拟化技术及其模式，使得镜像轻量而小巧且易于部署。</p></li><li><p>容器（ <code>Container</code> ）</p><p>容器是镜像的可运行实例。您可以使用 Docker API 或 <code>CLI</code> 进行创建、启动、停止、移动或删除容器。也可以将容器连接到一个或多个网络，以为其附加存储，甚至可以根据当前的状态创建新的镜像。</p><p>默认情况下，一个容器与其他容器，及其自身所在的主机是相对隔离的。</p><p>命令示例：docker run</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command=""></td><td><pre><span class="token comment"># 使用 docker 运行一个 ubuntu 容器，以交互的方式添加到本地命令行会话，并运行 /bin/bash</span></pre></td></tr><tr><td data-num="2"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker run -i -t ubuntu /bin/bash</pre></td></tr></table></figure><p>运行该命令时，将发生以下情况：</p><ol><li><p>如果当前主机本地没有该镜像， Docker 会从配置的注册表中进行提取，这一步骤等同于 <code>docker pull ubuntu</code> 。</p></li><li><p>Docker 会创建一个新的容器，这一步骤等同于 <code>docker container create</code> 。</p></li><li><p>Docker 为容器分配一个读写文件系统，作为它的最后一层。这允许正在运行的容器在其本地文件系统中创建或修改文件和目录。</p></li><li><p>Docker 创建一个网络接口来将容器连接到默认网络，其中包括为容器分配 IP 地址。默认情况下，容器可以使用主机的网络连接连接到外部网络。</p></li><li><p>Docker 启动容器并执行 <code>/bin/bash</code> 。由于容器以交互方式运行并附加到您的终端（由于 <code>-i</code> 和 <code>-t</code> 标志），您可以在输出记录到终端时使用键盘提供输入。</p><blockquote><p>docker 中必须保持至少一个进程运行，否则容器会自动退出。这里在启动时指定启动了 <code>/bin/bash</code> 进程。</p></blockquote></li><li><p>当输入 <code>exit</code> 以终止 <code>/bin/bash</code> 命令时，容器会停止，但不会被移除。您可以重新启动或删除它。</p></li></ol></li><li><p>仓库（ <code>Repository</code> ）</p><p>Docker 仓库与代码仓库类似，所不同的是它用于集中存放镜像。Docker 仓库存放于 Docker 注册表中，通常情况下，注册表中会有多个仓库，而仓库中则存放一类镜像，每个镜像利用 tag 进行区分，比如 Ubuntu 仓库中存放有多个版本的 Ubuntu 镜像。</p></li></ol><h4 id="底层技术支持"><a class="anchor" href="#底层技术支持">#</a> 底层技术支持</h4><p>Docker 是使用 <code>Golang</code> 编写的，并利用 Liunx 内核的几个特征来提供其功能， Docker 使用一种被称为 <code>namespaces</code> 的技术来提供隔离的工作空间，这种工作空间即被称为容器。当运行一个容器时， Docker 会为该容器创建一组命名空间。</p><p>这些命名空间提供了一层隔离。容器的每个方面都在单独的命名空间中运行，并且其访问权限仅限于该命名空间。</p><h3 id="docker-安装"><a class="anchor" href="#docker-安装">#</a> Docker 安装</h3><blockquote><p>警告：切勿在没有配置 Docker YUM 源的情况下直接使用 yum 命令安装 Docker 。</p></blockquote><h4 id="系统要求"><a class="anchor" href="#系统要求">#</a> 系统要求</h4><p>Docker 支持 64 位版本 CentOS 7/8，并且要求内核版本不低于 3.10。 CentOS 7 满足最低内核的要求，但由于内核版本比较低，部分功能（如 <code>overlay2</code> 存储层驱动）无法使用，并且部分功能可能不太稳定。</p><blockquote><p>查看 CentOS 版本： <code>cat /etc/redhat-release</code> 或 <code>cat /etc/os-release</code></p></blockquote><h4 id="卸载旧版本"><a class="anchor" href="#卸载旧版本">#</a> 卸载旧版本</h4><p>旧版本的 Docker 称为 docker 或者 <code>docker-engine</code> ，如果安装了这些，请卸载它们以及相关的依赖项：</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx ~] $"></td><td><pre><span class="token function">sudo</span> yum remove docker <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="2"></td><td data-command=""></td><td><pre>            docker-client <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="3"></td><td data-command=""></td><td><pre>            docker-client-latest <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="4"></td><td data-command=""></td><td><pre>            docker-common <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="5"></td><td data-command=""></td><td><pre>            docker-latest <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="6"></td><td data-command=""></td><td><pre>            docker-latest-logrotate <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="7"></td><td data-command=""></td><td><pre>            docker-logrotate <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="8"></td><td data-command=""></td><td><pre>            docker-engine</pre></td></tr></table></figure><h4 id="使用-yum-安装"><a class="anchor" href="#使用-yum-安装">#</a> 使用 yum 安装</h4><p>执行以下命令安装依赖包：</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx ~] $"></td><td><pre><span class="token function">sudo</span> yum <span class="token function">install</span> -y yum-utils</pre></td></tr></table></figure><p>执行以下命令设置 <code>yum</code> 软件源：</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command=""></td><td><pre><span class="token comment"># 阿里镜像源（国内推荐）</span></pre></td></tr><tr><td data-num="2"></td><td data-command="[root@xxx ~] $"></td><td><pre><span class="token function">sudo</span> yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</pre></td></tr><tr><td data-num="3"></td><td data-command=""></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td data-command=""></td><td><pre><span class="token comment"># Docker 官方镜像源</span></pre></td></tr><tr><td data-num="5"></td><td data-command=""></td><td><pre><span class="token comment"># sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span></pre></td></tr><tr><td data-num="6"></td><td data-command=""></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td data-command=""></td><td><pre><span class="token comment"># 测试版本 Docker</span></pre></td></tr><tr><td data-num="8"></td><td data-command=""></td><td><pre><span class="token comment"># sudo yum-config-manager --enable docker-ce-test</span></pre></td></tr></table></figure><h4 id="安装-docker"><a class="anchor" href="#安装-docker">#</a> 安装 Docker</h4><p>更新 <code>yum</code> 软件源缓存，并安装 <code>docker-ce</code> 。</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command=""></td><td><pre><span class="token comment"># 更新 yum 软件包索引</span></pre></td></tr><tr><td data-num="2"></td><td data-command="[root@xxx ~] $"></td><td><pre>yum makecache fast</pre></td></tr><tr><td data-num="3"></td><td data-command=""></td><td><pre><span class="token comment"># docker-ce 指的是社区版</span></pre></td></tr><tr><td data-num="4"></td><td data-command="[root@xxx ~] $"></td><td><pre><span class="token function">sudo</span> yum <span class="token function">install</span> docker-ce docker-ce-cli containerd.io</pre></td></tr></table></figure><blockquote><p>注：使用阿里云服务器的在这里可能会有些坑。</p></blockquote><h4 id="启动-docker"><a class="anchor" href="#启动-docker">#</a> 启动 Docker</h4><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command=""></td><td><pre><span class="token comment"># 设置 docker 开机启动</span></pre></td></tr><tr><td data-num="2"></td><td data-command="[root@xxx ~] $"></td><td><pre><span class="token function">sudo</span> systemctl <span class="token builtin class-name">enable</span> docker</pre></td></tr><tr><td data-num="3"></td><td data-command="[root@xxx ~] $"></td><td><pre><span class="token function">sudo</span> systemctl <span class="token builtin class-name">enable</span> containerd</pre></td></tr><tr><td data-num="4"></td><td data-command=""></td><td><pre><span class="token comment"># 启动 docker</span></pre></td></tr><tr><td data-num="5"></td><td data-command="[root@xxx ~] $"></td><td><pre><span class="token function">sudo</span> systemctl start docker</pre></td></tr></table></figure><p>如需禁用开机启动</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx ~] $"></td><td><pre><span class="token function">sudo</span> systemctl disable docker</pre></td></tr><tr><td data-num="2"></td><td data-command="[root@xxx ~] $"></td><td><pre><span class="token function">sudo</span> systemctl disable containerd</pre></td></tr></table></figure><h4 id="建立-docker-用户组"><a class="anchor" href="#建立-docker-用户组">#</a> 建立 Docker 用户组</h4><p>默认情况下， <code>docker</code> 命令会使用 <code>Unix</code> 套接字与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code> 组的用户才可以访问 Docker 引擎的 Unix socket 。出于安全考虑，一般 Linux 系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用 <code>docker</code> 的用户加入 <code>docker</code> 用户组。</p><p>建立 <code>docker</code> 组：</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx ~] $"></td><td><pre><span class="token function">sudo</span> <span class="token function">groupadd</span> docker</pre></td></tr></table></figure><p>将当前用户加入 <code>docker</code> 组：</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx ~] $"></td><td><pre><span class="token function">sudo</span> <span class="token function">usermod</span> -aG docker <span class="token environment constant">$USER</span></pre></td></tr></table></figure><h4 id="测试-docker-安装"><a class="anchor" href="#测试-docker-安装">#</a> 测试 Docker 安装</h4><ol><li><p>启动服务</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx ~] $"></td><td><pre><span class="token function">service</span> docker start</pre></td></tr></table></figure></li><li><p>查看 docker 版本</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker version</pre></td></tr></table></figure></li><li><p>拉取测试镜像</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker run --rm hello-world <span class="token comment"># --rm 启动成功后就删掉</span></pre></td></tr><tr><td data-num="2"></td><td data-command=""></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td data-command=""></td><td><pre>Unable to <span class="token function">find</span> image <span class="token string">'hello-world:latest'</span> locally</pre></td></tr><tr><td data-num="4"></td><td data-command=""></td><td><pre>latest: Pulling from library/hello-world</pre></td></tr><tr><td data-num="5"></td><td data-command=""></td><td><pre>b8dfde127a29: Pull complete </pre></td></tr><tr><td data-num="6"></td><td data-command=""></td><td><pre>Digest: sha256:df5f5184104426b65967e016ff2ac0bfcd44ad7899ca3bbcf8e44e4461491a9e</pre></td></tr><tr><td data-num="7"></td><td data-command=""></td><td><pre>Status: Downloaded newer image <span class="token keyword">for</span> hello-world:latest</pre></td></tr><tr><td data-num="8"></td><td data-command=""></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td data-command=""></td><td><pre>Hello from Docker<span class="token operator">!</span></pre></td></tr><tr><td data-num="10"></td><td data-command=""></td><td><pre>This message shows that your installation appears to be working correctly.</pre></td></tr><tr><td data-num="11"></td><td data-command=""></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td data-command=""></td><td><pre>To generate this message, Docker took the following steps:</pre></td></tr><tr><td data-num="13"></td><td data-command=""></td><td><pre> <span class="token number">1</span>. The Docker client contacted the Docker daemon.</pre></td></tr><tr><td data-num="14"></td><td data-command=""></td><td><pre> <span class="token number">2</span>. The Docker daemon pulled the <span class="token string">"hello-world"</span> image from the Docker Hub.</pre></td></tr><tr><td data-num="15"></td><td data-command=""></td><td><pre>    <span class="token punctuation">(</span>amd64<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td data-command=""></td><td><pre> <span class="token number">3</span>. The Docker daemon created a new container from that image <span class="token function">which</span> runs the</pre></td></tr><tr><td data-num="17"></td><td data-command=""></td><td><pre>    executable that produces the output you are currently reading.</pre></td></tr><tr><td data-num="18"></td><td data-command=""></td><td><pre> <span class="token number">4</span>. The Docker daemon streamed that output to the Docker client, <span class="token function">which</span> sent it</pre></td></tr><tr><td data-num="19"></td><td data-command=""></td><td><pre>    to your terminal.</pre></td></tr><tr><td data-num="20"></td><td data-command=""></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td data-command=""></td><td><pre>To try something <span class="token function">more</span> ambitious, you can run an Ubuntu container with:</pre></td></tr><tr><td data-num="22"></td><td data-command=""></td><td><pre> $ docker run -it ubuntu <span class="token function">bash</span></pre></td></tr><tr><td data-num="23"></td><td data-command=""></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td data-command=""></td><td><pre>Share images, automate workflows, and <span class="token function">more</span> with a <span class="token function">free</span> Docker ID:</pre></td></tr><tr><td data-num="25"></td><td data-command=""></td><td><pre> https://hub.docker.com/</pre></td></tr><tr><td data-num="26"></td><td data-command=""></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td data-command=""></td><td><pre>For <span class="token function">more</span> examples and ideas, visit:</pre></td></tr><tr><td data-num="28"></td><td data-command=""></td><td><pre> https://docs.docker.com/get-started/</pre></td></tr></table></figure><p>如果正常输出如上信息，则表示 docker 已安装成功。</p><blockquote><p>使用 docker 命令获取镜像时，默认会先从本地进行查找，如果本地不存在，则会从配置的镜像源中下载。</p></blockquote></li><li><p>查看本地镜像</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker images</pre></td></tr><tr><td data-num="2"></td><td data-command=""></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td data-command=""></td><td><pre>REPOSITORY    TAG       IMAGE ID       CREATED        SIZE</pre></td></tr><tr><td data-num="4"></td><td data-command=""></td><td><pre>hello-world   latest    d1165f221234   <span class="token number">5</span> months ago   <span class="token number">13</span>.3kB</pre></td></tr></table></figure></li></ol><h4 id="配置镜像加速"><a class="anchor" href="#配置镜像加速">#</a> 配置镜像加速</h4><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command=""></td><td><pre><span class="token comment"># 创建并打开 daemon.json 文件</span></pre></td></tr><tr><td data-num="2"></td><td data-command="[root@xxx ~] $"></td><td><pre><span class="token function">vi</span> /etc/docker/daemon.json</pre></td></tr><tr><td data-num="3"></td><td data-command=""></td><td><pre><span class="token comment"># 写入内容</span></pre></td></tr><tr><td data-num="4"></td><td data-command=""></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td data-command=""></td><td><pre>  <span class="token string">"registry-mirrors"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token string">"您的镜像地址"</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="6"></td><td data-command=""></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td data-command=""></td><td><pre><span class="token comment"># 保存退出</span></pre></td></tr><tr><td data-num="8"></td><td data-command=""></td><td><pre><span class="token comment"># 重启</span></pre></td></tr><tr><td data-num="9"></td><td data-command="[root@xxx ~] $"></td><td><pre><span class="token function">sudo</span> systemctl daemon-reload</pre></td></tr><tr><td data-num="10"></td><td data-command=""></td><td><pre><span class="token comment"># 重启 docker</span></pre></td></tr><tr><td data-num="11"></td><td data-command="[root@xxx ~] $"></td><td><pre><span class="token function">sudo</span> systemctl restart docker</pre></td></tr></table></figure><p>如何获取自己的镜像地址？</p><ol><li>阿里云<ul><li>登录阿里云控制台。</li><li>搜索并进入 <code>容器镜像服务</code> 。</li><li>找到 <code>镜像工具</code> / <code>镜像加速器</code> 即可获取到唯一的镜像地址。</li></ul></li><li>华为云<ul><li>登录华为云控制台。</li><li>搜索并进入 <code>容器镜像服务</code> 。</li><li>找到 <code>镜像资源</code> / <code>镜像中心</code> 并添加 <code>镜像加速器</code> 即可获取到唯一的镜像地址。</li></ul></li></ol><blockquote><p>获取其余服务器商提供的镜像加速器方式均相似。</p></blockquote><h3 id="卸载-docker"><a class="anchor" href="#卸载-docker">#</a> 卸载 Docker</h3><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command=""></td><td><pre><span class="token comment"># 卸载依赖</span></pre></td></tr><tr><td data-num="2"></td><td data-command="[root@xxx ~] $"></td><td><pre><span class="token function">sudo</span> yum remove docker-ce docker-ce-cli containerd.io</pre></td></tr><tr><td data-num="3"></td><td data-command=""></td><td><pre><span class="token comment"># 删除目录</span></pre></td></tr><tr><td data-num="4"></td><td data-command="[root@xxx ~] $"></td><td><pre><span class="token function">sudo</span> <span class="token function">rm</span> -rf /var/lib/docker</pre></td></tr><tr><td data-num="5"></td><td data-command="[root@xxx ~] $"></td><td><pre><span class="token function">sudo</span> <span class="token function">rm</span> -rf /var/lib/containerd</pre></td></tr></table></figure><h3 id="docker-启动流程及原理"><a class="anchor" href="#docker-启动流程及原理">#</a> Docker 启动流程及原理</h3><h4 id="docker-启动流程"><a class="anchor" href="#docker-启动流程">#</a> Docker 启动流程</h4><p><img data-src="https://img.xfc-exclave.com/2021/08/8a14ba52293bd7cdbf600968ea481e551628602757.png" alt="Docker启动流程图"></p><h4 id="docker-vs-虚拟机"><a class="anchor" href="#docker-vs-虚拟机">#</a> Docker VS 虚拟机</h4><p>Docker 有着比虚拟机更少的抽象层，且 Docker 容器在 Linux 本机上运行，它与其他容器共享主机的内核，因此在新建一个容器时， Docker 并不需要像虚拟机一样重新加载一个操作系统的内核，避免了很多引导操作。</p><p>而虚拟机（VM）则是运行一个完整的 “Guest 操作系统”，通过虚拟机监控程序对主机资源进行虚拟访问。一般来说，虚拟机除了应用程序逻辑所消耗的开销之外，还会产生很多开销。</p><p><img data-src="https://img.xfc-exclave.com/2021/08/e781c900e152e279625ea9056b299f661628512294.png" alt="Docker VS 虚拟机"></p><h3 id="docker-常用命令"><a class="anchor" href="#docker-常用命令">#</a> Docker 常用命令</h3><h4 id="帮助命令"><a class="anchor" href="#帮助命令">#</a> 帮助命令</h4><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command=""></td><td><pre><span class="token comment"># 显示 docker 版本信息</span></pre></td></tr><tr><td data-num="2"></td><td data-command="[root@xxx ~] $"></td><td><pre>$ docker version</pre></td></tr><tr><td data-num="3"></td><td data-command=""></td><td><pre><span class="token comment"># 显示 docker 详细信息</span></pre></td></tr><tr><td data-num="4"></td><td data-command="[root@xxx ~] $"></td><td><pre>$ docker info</pre></td></tr><tr><td data-num="5"></td><td data-command=""></td><td><pre><span class="token comment"># 查看 docker 状态</span></pre></td></tr><tr><td data-num="6"></td><td data-command="[root@xxx ~] $"></td><td><pre>$ docker stats</pre></td></tr><tr><td data-num="7"></td><td data-command=""></td><td><pre><span class="token comment"># 帮助命令</span></pre></td></tr><tr><td data-num="8"></td><td data-command="[root@xxx ~] $"></td><td><pre>$ docker xxx --help</pre></td></tr></table></figure><p><img data-src="https://img.xfc-exclave.com/2021/08/681651c6f99d3f25184a775dc8ee56bb1628602735.jpeg" alt="Docker命令图表"></p><blockquote><p>Docker 命令行参考文档：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vcmVmZXJlbmNl">https://docs.docker.com/reference</span></p></blockquote><h4 id="镜像命令"><a class="anchor" href="#镜像命令">#</a> 镜像命令</h4><ol><li><p>docker images</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker images <span class="token comment"># 查看镜像</span></pre></td></tr><tr><td data-num="2"></td><td data-command=""></td><td><pre>REPOSITORY    TAG       IMAGE ID       CREATED        SIZE</pre></td></tr><tr><td data-num="3"></td><td data-command=""></td><td><pre>hello-world   latest    d1165f221234   <span class="token number">5</span> months ago   <span class="token number">13</span>.3kB</pre></td></tr><tr><td data-num="4"></td><td data-command=""></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td data-command=""></td><td><pre><span class="token comment"># REPOSITORY: 镜像的仓库源</span></pre></td></tr><tr><td data-num="6"></td><td data-command=""></td><td><pre><span class="token comment"># TAG: 镜像的标签</span></pre></td></tr><tr><td data-num="7"></td><td data-command=""></td><td><pre><span class="token comment"># IMAGE ID: 镜像 ID</span></pre></td></tr><tr><td data-num="8"></td><td data-command=""></td><td><pre><span class="token comment"># CREATED: 创建时间</span></pre></td></tr><tr><td data-num="9"></td><td data-command=""></td><td><pre><span class="token comment"># SIZE: 镜像大小</span></pre></td></tr><tr><td data-num="10"></td><td data-command=""></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker images -a <span class="token comment"># -all 列出所有镜像</span></pre></td></tr><tr><td data-num="12"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker images -q <span class="token comment"># -quiet 仅列出镜像的 ID</span></pre></td></tr><tr><td data-num="13"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker images -aq <span class="token comment"># 组合使用</span></pre></td></tr></table></figure></li><li><p>docker search</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker search mysql <span class="token comment"># 搜索 mysql 镜像</span></pre></td></tr><tr><td data-num="2"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker search mysql --filter<span class="token operator">=</span>STARS<span class="token operator">=</span><span class="token number">3000</span> <span class="token comment"># 过滤：过滤 STARS 大于 3000 的 mysql 镜像</span></pre></td></tr></table></figure></li><li><p>docker pull</p><blockquote><p>docker 镜像既可使用命令拉取，也可以前往 <span class="exturl" data-url="aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS8=">Docker Hub</span> 进行下载。</p></blockquote><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker pull mysql <span class="token comment"># 拉取 mysql 镜像</span></pre></td></tr><tr><td data-num="2"></td><td data-command=""></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td data-command=""></td><td><pre>Using default tag: latest <span class="token comment"># 不指定 tag 时默认下载最新版本</span></pre></td></tr><tr><td data-num="4"></td><td data-command=""></td><td><pre>latest: Pulling from library/mysql</pre></td></tr><tr><td data-num="5"></td><td data-command=""></td><td><pre>45b42c59be33: Pull complete <span class="token comment"># 分层下载（分层下载会复用已下载的 layer，即已存在的 layer 不会重复下载）</span></pre></td></tr><tr><td data-num="6"></td><td data-command=""></td><td><pre>b4f790bd91da: Pull complete </pre></td></tr><tr><td data-num="7"></td><td data-command=""></td><td><pre>325ae51788e9: Pull complete </pre></td></tr><tr><td data-num="8"></td><td data-command=""></td><td><pre>adcb9439d751: Pull complete </pre></td></tr><tr><td data-num="9"></td><td data-command=""></td><td><pre>174c7fe16c78: Pull complete </pre></td></tr><tr><td data-num="10"></td><td data-command=""></td><td><pre>698058ef136c: Pull complete </pre></td></tr><tr><td data-num="11"></td><td data-command=""></td><td><pre>4690143a669e: Pull complete </pre></td></tr><tr><td data-num="12"></td><td data-command=""></td><td><pre>f7599a246fd6: Pull complete </pre></td></tr><tr><td data-num="13"></td><td data-command=""></td><td><pre>35a55bf0c196: Pull complete </pre></td></tr><tr><td data-num="14"></td><td data-command=""></td><td><pre>790ac54f4c47: Pull complete </pre></td></tr><tr><td data-num="15"></td><td data-command=""></td><td><pre>b0ddd5d1b543: Pull complete </pre></td></tr><tr><td data-num="16"></td><td data-command=""></td><td><pre>1aefd67cb33d: Pull complete </pre></td></tr><tr><td data-num="17"></td><td data-command=""></td><td><pre>Digest: sha256:03306a1f248727ec979f61424c5fb5150e2c5fd2436f2561c5259b1258d6063c <span class="token comment"># 签名，用于防伪</span></pre></td></tr><tr><td data-num="18"></td><td data-command=""></td><td><pre>Status: Downloaded newer image <span class="token keyword">for</span> mysql:latest</pre></td></tr><tr><td data-num="19"></td><td data-command=""></td><td><pre>docker.io/library/mysql:latest <span class="token comment"># 真实地址</span></pre></td></tr><tr><td data-num="20"></td><td data-command=""></td><td><pre><span class="token comment"># docker pull mysql</span></pre></td></tr><tr><td data-num="21"></td><td data-command=""></td><td><pre><span class="token comment"># 等价于</span></pre></td></tr><tr><td data-num="22"></td><td data-command=""></td><td><pre><span class="token comment"># docker pull docker.io/library/mysql:latest</span></pre></td></tr><tr><td data-num="23"></td><td data-command=""></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker pull mysql:5.7 <span class="token comment"># 指定版本拉取镜像</span></pre></td></tr></table></figure></li><li><p>docker rmi</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker rmi -f d1165f221234 <span class="token comment"># docker remove image: 删除指定的镜像</span></pre></td></tr><tr><td data-num="2"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker rmi -f d1165f221234 8457e9155715 <span class="token comment"># 删除多个镜像</span></pre></td></tr><tr><td data-num="3"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker rmi -f <span class="token variable"><span class="token variable">$(</span>docker images -aq<span class="token variable">)</span></span> <span class="token comment"># 删除所有（递归删除）</span></pre></td></tr></table></figure></li></ol><h4 id="容器命令"><a class="anchor" href="#容器命令">#</a> 容器命令</h4><p>拉取一个测试镜像。</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker pull centos</pre></td></tr></table></figure><ol><li><p>创建并启动容器</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker run <span class="token punctuation">[</span>可选参数<span class="token punctuation">]</span> <span class="token punctuation">[</span>image<span class="token punctuation">]</span> <span class="token comment"># 新建并启动容器</span></pre></td></tr><tr><td data-num="2"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker run -it centos /bin/bash <span class="token comment"># 启动并以交互的方式进入容器</span></pre></td></tr><tr><td data-num="3"></td><td data-command=""></td><td><pre><span class="token comment"># 后台以端口 80 启动 centos，并命名为 centos01，并映射到外部端口 3344</span></pre></td></tr><tr><td data-num="4"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker run -d --name centos01 -p <span class="token number">3344</span>:80</pre></td></tr><tr><td data-num="5"></td><td data-command=""></td><td><pre><span class="token comment"># 进入容器</span></pre></td></tr><tr><td data-num="6"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker run -it centos /bin/bash</pre></td></tr><tr><td data-num="7"></td><td data-command="[root@01939a1ac7cd /] $"></td><td><pre><span class="token punctuation">[</span>root@01939a1ac7cd /<span class="token punctuation">]</span><span class="token comment"># ls</span></pre></td></tr><tr><td data-num="8"></td><td data-command=""></td><td><pre>bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</pre></td></tr></table></figure></li><li><p>退出容器</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx ~] $"></td><td><pre><span class="token builtin class-name">exit</span> <span class="token comment"># 退出容器（停止并退出）</span></pre></td></tr><tr><td data-num="2"></td><td data-command=""></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td data-command=""></td><td><pre><span class="token comment"># ctrl + P + Q 退出容器（退出但容器不停止）</span></pre></td></tr><tr><td data-num="4"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker run -it centos /bin/bash</pre></td></tr><tr><td data-num="5"></td><td data-command="[root@286b1fb8e21d /]# [root@xxxxxxxx /]#"></td><td><pre>docker <span class="token function">ps</span></pre></td></tr><tr><td data-num="6"></td><td data-command=""></td><td><pre>CONTAINER ID   IMAGE     COMMAND       CREATED              STATUS</pre></td></tr><tr><td data-num="7"></td><td data-command=""></td><td><pre>286b1fb8e21d   centos    <span class="token string">"/bin/bash"</span>   About a minute ago   Up About a minute</pre></td></tr></table></figure></li><li><p>查看运行的容器</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker <span class="token function">ps</span> <span class="token comment"># 查看正在运行的容器</span></pre></td></tr><tr><td data-num="2"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker <span class="token function">ps</span> -a <span class="token comment"># 查看所有运行的容器（包括曾经运行过的）</span></pre></td></tr><tr><td data-num="3"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker <span class="token function">ps</span> -n<span class="token operator">=</span><span class="token number">2</span> <span class="token comment"># 显示运行过的 2 个容器</span></pre></td></tr><tr><td data-num="4"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker <span class="token function">ps</span> -aq <span class="token comment"># 显示当前正在运行的容器 ID</span></pre></td></tr></table></figure></li><li><p>删除容器</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker <span class="token function">rm</span> <span class="token punctuation">[</span>容器ID<span class="token punctuation">]</span> <span class="token comment"># 移除指定的容器（不能移除正在运行的容器）</span></pre></td></tr><tr><td data-num="2"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker <span class="token function">rm</span> -f <span class="token variable"><span class="token variable">$(</span>docker <span class="token function">ps</span> -aq<span class="token variable">)</span></span> <span class="token comment"># 移除所有的容器（-f 可删除正在运行的容器）</span></pre></td></tr><tr><td data-num="3"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker <span class="token function">ps</span> -a -q<span class="token operator">|</span><span class="token function">xargs</span> docker <span class="token function">rm</span> <span class="token comment"># 移除所有的容器</span></pre></td></tr></table></figure></li><li><p>启动和停止容器</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker start <span class="token punctuation">[</span>容器ID<span class="token punctuation">]</span> <span class="token comment"># 启动容器</span></pre></td></tr><tr><td data-num="2"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker restart <span class="token punctuation">[</span>容器ID<span class="token punctuation">]</span> <span class="token comment"># 重启容器</span></pre></td></tr><tr><td data-num="3"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker stop <span class="token punctuation">[</span>容器ID<span class="token punctuation">]</span> <span class="token comment"># 停止容器</span></pre></td></tr><tr><td data-num="4"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker <span class="token function">kill</span> <span class="token punctuation">[</span>容器ID<span class="token punctuation">]</span> <span class="token comment"># 强制停止容器</span></pre></td></tr></table></figure></li><li><p>后台启动</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker run -d centos <span class="token comment"># 后台启动 centos</span></pre></td></tr><tr><td data-num="2"></td><td data-command=""></td><td><pre><span class="token comment"># 注：docker 必须保证至少一个运行的进程，否则会自动停止</span></pre></td></tr></table></figure></li><li><p>查看日志</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker logs -tf --tail <span class="token number">10</span> 8b1c31f83ff8 <span class="token comment"># 查看 10 条日志</span></pre></td></tr><tr><td data-num="2"></td><td data-command=""></td><td><pre><span class="token comment"># -tf 显示时间戳（格式化显示）</span></pre></td></tr></table></figure></li><li><p>查看容器内部的进程</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker <span class="token function">top</span> 8b1c31f83ff8 <span class="token comment"># 查看指定容器内部运行的进程</span></pre></td></tr></table></figure></li><li><p>查看镜像的元数据</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker inspect 8b1c31f83ff8 <span class="token comment"># 查看指定容器的所有信息</span></pre></td></tr></table></figure></li><li><p>进入当前正在运行的容器</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker <span class="token builtin class-name">exec</span> -it 8b1c31f83ff8 /bin/bash <span class="token comment"># 进入指定的容器并启动命令行（进入后开启一个新的终端）</span></pre></td></tr><tr><td data-num="2"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker attach 8b1c31f83ff8 <span class="token comment"># 进入指定容器（不会启动新的进程）</span></pre></td></tr></table></figure></li><li><p>从容器内拷贝文件到主机</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker <span class="token function">cp</span> <span class="token punctuation">[</span>容器ID<span class="token punctuation">]</span>:<span class="token punctuation">[</span>路径<span class="token punctuation">]</span> <span class="token punctuation">[</span>路径<span class="token punctuation">]</span> <span class="token comment"># 将容器内指定路径的文件拷贝到主机</span></pre></td></tr><tr><td data-num="2"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker <span class="token function">cp</span> 8b1c31f83ff8:/home/test.java /home <span class="token comment"># 将容器内的 /home/test.java 文件拷贝到主机 /home 目录下</span></pre></td></tr></table></figure></li></ol><h4 id="可视化工具-portainer"><a class="anchor" href="#可视化工具-portainer">#</a> 可视化工具 Portainer</h4><blockquote><p>Portainer 官方网站：<span class="exturl" data-url="aHR0cHM6Ly93d3cucG9ydGFpbmVyLmlv">https://www.portainer.io</span></p></blockquote><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker run -d -p <span class="token number">8088</span>:9000 -v /root/portainer:/data -v /var/run/docker.sock:/var/run/docker.sock --name dev-portainer portainer/portainer</pre></td></tr><tr><td data-num="2"></td><td data-command=""></td><td><pre><span class="token comment"># 查看是否启动成功</span></pre></td></tr><tr><td data-num="3"></td><td data-command="[root@xxx ~] $"></td><td><pre><span class="token function">curl</span> localhost:8088</pre></td></tr></table></figure><p>此时从外部浏览器访问该主机的对应端口，可以看到如下界面：</p><p><img data-src="https://img.xfc-exclave.com/2021/08/a8ad2462956f5a99deeb70cfca98e0ff1628602584.png" alt="Portainer初始页面"></p><p>完善信息后创建用户后即可登录。</p><blockquote><p>注：如果是云服务器，需要确认在安全组规则中是否开放对应的端口。这里不推荐使用可视化工具，如有兴趣，登录成功后自行探索。</p></blockquote><h3 id="docker-镜像详解"><a class="anchor" href="#docker-镜像详解">#</a> Docker 镜像详解</h3><h4 id="镜像和容器"><a class="anchor" href="#镜像和容器">#</a> 镜像和容器</h4><p>镜像由多个层组成，每层叠加之后，从外部看来就如一个独立的对象。镜像内部是一个精简的操作系统（OS），同时还包含应用运行所必须的文件和依赖包。因为容器的设计初衷就是快速和小巧，所以镜像通常都比较小。</p><p>镜像就像停止运行的容器（类），但实际上，它可以停止某个容器的运行，并从中创建新的镜像。在该前提下，镜像可以理解为一种构建时（build-time）结构，而容器可以理解为一种运行时（run-time）结构，如下图所示。</p><p><img data-src="https://img.xfc-exclave.com/2021/08/ae6291c5590378207dc3680076fc89f61628601022.gif" alt="镜像和容器间的关系"></p><p>我们通常使用 <code>docker container run</code> 和 <code>docker service create</code> 命令从某个镜像启动一个或多个容器，一旦容器从镜像启动后，二者之间就变成了互相依赖的关系，并且在镜像上启动的容器全部停止之前，镜像是无法被删除的。尝试删除镜像而不停止或销毁使用它的容器，会导致出错。</p><h4 id="docker-镜像加载原理"><a class="anchor" href="#docker-镜像加载原理">#</a> Docker 镜像加载原理</h4><h5 id="unionfs联合文件系统"><a class="anchor" href="#unionfs联合文件系统">#</a> UnionFS（联合文件系统）</h5><p>UnionFS（联合文件系统）： UnionFS 是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（unite several directories into a single virtual filesystem）。 UnionFS 是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。<br><strong>特性：</strong> 一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p><h5 id="docker-镜像加载原理-2"><a class="anchor" href="#docker-镜像加载原理-2">#</a> Docker 镜像加载原理</h5><p>Docker 的镜像实际上是由一层一层的文件系统组成的，这种层级的文件系统（UFS）主要包含 <code>bootleader</code> 和 <code>kernel</code> ， bootleader 主要是引导加载 kernel ， Linux 刚启动会加载 bootfs 文件系统，在 Docker 镜像的最底层是 bootfs 。这一层与我们典型的 Linux/Unix 系统是一样的，包含 boot 加载器和内核。当 boot 加载完成之后，整个内核就都在内存中了，此时内存的使用权已由 bootfs 转交给内核，此时系统也会卸载 bootfs 。</p><p>roofts（root file system）就是各种不同的操作系统发行版，比如 Ubuntu 、 Centos 等。</p><p>对于个精简的 OS ， rootfs 可以很小，只需要包合最基本的命令，工具和程序库就可以了，因为底层直接用宿主机的内核，自己只需要提供 rootfs 就可以了。</p><p>由此可见对于不同的 Linux 发行版， boots 基本是一致的， rootfs 会有差別，因此不同的发行版可以公用 bootfs 。</p><h5 id="镜像的分层结构"><a class="anchor" href="#镜像的分层结构">#</a> 镜像的分层结构</h5><p>Docker 支持通过扩展现有镜像，创建新的镜像。</p><p><img data-src="https://img.xfc-exclave.com/2021/08/c4c69be4310118b7eda353256d3c5a221628601033.jpeg" alt="层级文件系统图示"></p><p>事实上，所有的 Docker 镜像都起始于一个基础的镜像层，当进行修改或增加新的内容时，就会在当前镜像层之上创建新的镜像层。</p><p>Docker 镜像采用这种分层结构的好处在于共享资源，多个镜像都从相同的基础层镜像创建而来， Docker 主机则只需要在磁盘上保存一份基础层镜像，同时内存中也只加载一份基础层镜像，就可以为所有容器提供服务了。</p><blockquote><p>Docker 通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统。</p></blockquote><p>Docker 的镜像都是只读的，而容器层则是可写的。当容器启动时，一个新的可写层被加载到镜像的顶部，它被称为容器层，在容器层之下，都是叫镜像层。</p><p>当我们对容器进行添加、删除或修改等操作时，其实所作用的是通过 <code>run</code> 命令启动后生成的一个新的容器层。</p><h5 id="提交镜像"><a class="anchor" href="#提交镜像">#</a> 提交镜像</h5><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command=""></td><td><pre><span class="token comment"># 将一个容器提交为新的镜像</span></pre></td></tr><tr><td data-num="2"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker commit -m <span class="token string">'镜像描述'</span> -a <span class="token string">'作者'</span> <span class="token punctuation">[</span>容器ID<span class="token punctuation">]</span> <span class="token punctuation">[</span>镜像名<span class="token punctuation">]</span></pre></td></tr></table></figure><blockquote><p>docker 原理与 git 相似，也可以简单理解为：原镜像 + 自己的文件 = 新的镜像</p></blockquote><h3 id="容器数据卷"><a class="anchor" href="#容器数据卷">#</a> 容器数据卷</h3><p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p><ul><li>数据卷可以在容器之间共享和重用。</li><li>对数据卷的修改会立马生效。</li><li>对数据卷的更新，不会影响镜像。</li><li>数据卷默认会一直存在，即使容器被删除。</li></ul><p>容器目录的挂载：</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker run -it -v <span class="token punctuation">[</span>宿主机目录<span class="token punctuation">]</span>:<span class="token punctuation">[</span>容器目录<span class="token punctuation">]</span> <span class="token comment"># 使用 -v 参数实现挂载</span></pre></td></tr><tr><td data-num="2"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker run -it -v /home/ceshi:/home centos /bin/bash <span class="token comment"># 将主机的 /home/ceshi 目录与容器内的目录 /home 进行挂载，挂载成功后，两个目录之间会自动进行双向同步。</span></pre></td></tr><tr><td data-num="3"></td><td data-command=""></td><td><pre><span class="token comment"># 指定多个 -v [宿主机目录]:[容器目录]，即可挂载多个目录。</span></pre></td></tr></table></figure><blockquote><p>数据卷的使用，类似于 Linux 下对目录或文件进行 mount ，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。</p></blockquote><h4 id="具名挂载与匿名挂载"><a class="anchor" href="#具名挂载与匿名挂载">#</a> 具名挂载与匿名挂载</h4><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command=""></td><td><pre><span class="token comment"># 匿名挂载，即没有指定容器内挂载目录对应的外部路径和名字</span></pre></td></tr><tr><td data-num="2"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker run -d -P --name nginx01 -v /etc/nginx nginx <span class="token comment"># 使用随机端口启动 nginx，并将目录 /etc/nginx 匿名挂载。</span></pre></td></tr><tr><td data-num="3"></td><td data-command=""></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker volume <span class="token function">ls</span> <span class="token comment"># 查看所有数据卷信息</span></pre></td></tr><tr><td data-num="5"></td><td data-command=""></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td data-command=""></td><td><pre><span class="token comment"># 具名挂载，即没有指定容器内挂载目录对应的外部路径，但指定了数据卷名字</span></pre></td></tr><tr><td data-num="7"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker run -d -P --name nginx02 -v nginx-test:/etc/nginx nginx</pre></td></tr><tr><td data-num="8"></td><td data-command=""></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td data-command=""></td><td><pre><span class="token comment"># 使用 docker inspect 查看容器详情，可以看到卷挂载路径信息。</span></pre></td></tr></table></figure><p>具名和匿名挂载会将数据卷挂载到 <code>/var/lib/docker/volumes/xxx/_data</code> 目录中。</p><blockquote><p>匿名挂载不易识别，不建议使用。</p></blockquote><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker run -d -P --name nginx01 -v /etc/nginx:ro nginx <span class="token comment"># ro -> 只读，只能通过书主机操作</span></pre></td></tr><tr><td data-num="2"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker run -d -P --name nginx01 -v /etc/nginx:rw nginx <span class="token comment"># rw -> 读写，默认值。</span></pre></td></tr></table></figure><h4 id="数据卷容器"><a class="anchor" href="#数据卷容器">#</a> 数据卷容器</h4><p>多个容器之间也可以通过 <code>--volunes-from</code> 挂载实现容器间数据共享。</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker run -it --name docker02 --volunes-from docker01 exclave/centos</pre></td></tr><tr><td data-num="2"></td><td data-command=""></td><td><pre><span class="token comment"># 启动镜像 exclave/centos 并命名为 docker02，且挂载到 docker01</span></pre></td></tr></table></figure><blockquote><p>容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用位置。</p><p>但如果容器挂载到了本地文件系统，移除所有容器，本地信息也不会丢失。</p></blockquote><h3 id="dockerfile"><a class="anchor" href="#dockerfile">#</a> DockerFile</h3><h4 id="dockerfile-构建示例"><a class="anchor" href="#dockerfile-构建示例">#</a> DockerFile 构建示例</h4><p><code>Dockerfile</code> 是一个文本文件，其内包含了一条条的指令（Instruction），每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><p>添加数据卷除了直接通过命令进行挂载外，还可以通过 dockerFile 进行添加，操作方式如下：</p><ol><li><p>创建一个 dockerfile 文件（名字可以随意），并在该文件中写入脚本。</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>FROM centos</pre></td></tr><tr><td data-num="2"></td><td><pre>VOLUME <span class="token punctuation">[</span><span class="token string">"volume01"</span>, <span class="token string">"volume02"</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="3"></td><td><pre>CMD <span class="token builtin class-name">echo</span> <span class="token string">"--------------success--------------"</span></pre></td></tr><tr><td data-num="4"></td><td><pre>CMD /bin/bash</pre></td></tr></table></figure><blockquote><p>FROM: 用于指定基础镜像，定制的镜像都是基于 FROM 的镜像。</p></blockquote></li><li><p>构建镜像</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command=""></td><td><pre><span class="token comment"># docker build -f [脚本路径]:[镜像标签] .</span></pre></td></tr><tr><td data-num="2"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker build -f dockerfile:v3 <span class="token builtin class-name">.</span></pre></td></tr></table></figure><blockquote><p>注意：命令结尾有一个 <code>.</code> ，代表着本次执行的上下文路径。</p></blockquote></li><li><p>启动构建成功后的镜像</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker run -it <span class="token punctuation">[</span>镜像ID<span class="token punctuation">]</span> /bin/bash</pre></td></tr></table></figure><p>启动成功后，根目录下会生成脚本中指定的挂载目录（匿名挂载）。</p></li></ol><h4 id="dockerfile-构建说明"><a class="anchor" href="#dockerfile-构建说明">#</a> DockerFile 构建说明</h4><ul><li>每个保留关键字都必须是大写。</li><li>执行顺序从上至下。</li><li><code>#</code> 表示注解。</li><li>每一个指令都会创建提交一个新的镜像层。</li></ul><h4 id="dockerfile-指令"><a class="anchor" href="#dockerfile-指令">#</a> DockerFile 指令</h4><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>FROM      <span class="token comment"># 基础镜像</span></pre></td></tr><tr><td data-num="2"></td><td><pre>MAINTAINER  <span class="token comment"># 镜像作者：姓名 + 邮箱</span></pre></td></tr><tr><td data-num="3"></td><td><pre>RUN       <span class="token comment"># 镜像构建时需要运行的命令</span></pre></td></tr><tr><td data-num="4"></td><td><pre>ADD       <span class="token comment"># 步骤</span></pre></td></tr><tr><td data-num="5"></td><td><pre>WORKDIR    <span class="token comment"># 镜像的工作目录</span></pre></td></tr><tr><td data-num="6"></td><td><pre>VOLUME     <span class="token comment"># 挂载目录</span></pre></td></tr><tr><td data-num="7"></td><td><pre>EXPOSE     <span class="token comment"># 指定暴露的端口</span></pre></td></tr><tr><td data-num="8"></td><td><pre>CMD       <span class="token comment"># 指定容器启动时要运行的命令（只有最后一个会生效，可被替代）</span></pre></td></tr><tr><td data-num="9"></td><td><pre>ENTRYPOINT  <span class="token comment"># 与 CMD 相似，但可以追加命令</span></pre></td></tr><tr><td data-num="10"></td><td><pre>ONBUILD    <span class="token comment"># （触发指令）</span></pre></td></tr><tr><td data-num="11"></td><td><pre>COPY      <span class="token comment"># 类似 ADD，将文件拷贝到镜像中</span></pre></td></tr><tr><td data-num="12"></td><td><pre>ENV       <span class="token comment"># 构建时设置环境变量</span></pre></td></tr></table></figure><blockquote><p>docker history [镜像 ID] 可以查看镜像的构建过程。</p><p>DockerFile 的官方命名文件为 <code>Dockerfile</code> ，编译时不指定 <code>-f</code> 参数则会自动读取该文件。</p></blockquote><h4 id="dockerfile-步骤总结"><a class="anchor" href="#dockerfile-步骤总结">#</a> DockerFile 步骤总结</h4><ol><li>编写一个 dockerfile 文件。</li><li>docker build 构建称为一个镜像。</li><li>docker run 运行镜像。</li><li>docker push 发布镜像（DockerHub、阿里云镜像仓库）</li></ol><h4 id="制作-tomcat-镜像"><a class="anchor" href="#制作-tomcat-镜像">#</a> 制作 Tomcat 镜像</h4><ol><li><p>准备目录及镜像文件。</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx ~] $"></td><td><pre><span class="token builtin class-name">cd</span> /usr</pre></td></tr><tr><td data-num="2"></td><td data-command="[root@xxx usr] $"></td><td><pre><span class="token function">mkdir</span> soft</pre></td></tr><tr><td data-num="3"></td><td data-command="[root@xxx usr] $"></td><td><pre><span class="token builtin class-name">cd</span> soft</pre></td></tr><tr><td data-num="4"></td><td data-command="[root@xxx soft] $"></td><td><pre><span class="token function">wget</span> https://mirrors.cnnic.cn/apache/tomcat/tomcat-9/v9.0.52/src/apache-tomcat-9.0.52-src.tar.gz</pre></td></tr><tr><td data-num="5"></td><td data-command="[root@xxx soft] $"></td><td><pre><span class="token function">wget</span> https://download.oracle.com/otn/java/jdk/8u301-b09/d3c52aa6bfa54d3ca74e617f18309292/jdk-8u301-linux-x64.tar.gz</pre></td></tr></table></figure></li><li><p>创建并编辑 <code>Dockerfile</code> 文件。</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx soft] $"></td><td><pre><span class="token function">vim</span> Dockerfile</pre></td></tr></table></figure><p>写入如下内容（可根据实际情况调整）：</p><figure class="highlight dockerfile"><figcaption data-lang="Docker"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token instruction"><span class="token keyword">FROM</span> centos</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token instruction"><span class="token keyword">MAINTAINER</span> Chinmoku&lt;xfc_exclave@163.com></span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token instruction"><span class="token keyword">ADD</span> jdk-8u301-linux-x64.tar.gz /usr/soft/</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token instruction"><span class="token keyword">ADD</span> apache-tomcat-9.0.52-src.tar.gz /usr/soft/</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token instruction"><span class="token keyword">RUN</span> yum -y install vim</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token instruction"><span class="token keyword">ENV</span> MYPATH /usr/soft</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token instruction"><span class="token keyword">WORKDIR</span> <span class="token variable">$MYPATH</span></span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token instruction"><span class="token keyword">ENV</span> JAVA_HOME /usr/soft/jdk1.8.0_301</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token instruction"><span class="token keyword">ENV</span> CLASSPATH <span class="token variable">$JAVA_HOME</span>/lib/dt.jar:<span class="token variable">$JAVA_HOME</span>/lib/tools.jar</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token instruction"><span class="token keyword">ENV</span> CATALINA_HOME /usr/soft/apache-tomcat-9.0.52-src</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token instruction"><span class="token keyword">ENV</span> CATALINA_BASH /usr/soft/apache-tomcat-9.0.52-src</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token instruction"><span class="token keyword">ENV</span> PATH <span class="token variable">$PATH</span>:<span class="token variable">$JAVA_HOME</span>/bin;<span class="token variable">$CATALINA_HOME</span>/lib;<span class="token variable">$CATALINA_BASH</span>/bin</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token instruction"><span class="token keyword">EXPOSE</span> 8080</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token instruction"><span class="token keyword">CMD</span> mkdir /usr/soft/apache-tomcat-9.0.52-src/logs &amp;&amp; chmod -R 777 /usr/soft/apache-tomcat-9.0.52-src/bin/*.sh &amp;&amp; /usr/soft/apache-tomcat-9.0.52-src/bin/startup.sh &amp;&amp; tail -F /usr/soft/apache-tomcat-9.0.52-src/bin/logs/catalina.out</span></pre></td></tr></table></figure></li><li><p>构建镜像。</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx soft] $"></td><td><pre>docker build -t mytomcat <span class="token builtin class-name">.</span></pre></td></tr><tr><td data-num="2"></td><td data-command="[root@xxx soft] $"></td><td><pre>docker images</pre></td></tr><tr><td data-num="3"></td><td data-command=""></td><td><pre>REPOSITORY   TAG       IMAGE ID       CREATED         SIZE</pre></td></tr><tr><td data-num="4"></td><td data-command=""></td><td><pre>mytomcat     latest    93a17796c1b6   <span class="token number">2</span> minutes ago   309MB</pre></td></tr><tr><td data-num="5"></td><td data-command=""></td><td><pre>centos       latest    300e315adb2f   <span class="token number">8</span> months ago    209MB</pre></td></tr></table></figure></li><li><p>启动容器。</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx soft] $"></td><td><pre>docker run -d -p <span class="token number">9090</span>:8080 --name ChinmokuTomcat -v /home/Chinmoku/build/tomcat/test/:/usr/local/apache-tomcat-9.0.52-src/webapps/test -v /home/Chinmoku/build/tomcat/tomcatlogs/:/usr/local/apache-tomcat-9.0.52-src/logs mytomcat</pre></td></tr><tr><td data-num="2"></td><td data-command=""></td><td><pre>d7cd19e650dd71c21d293199578acd80407d04c27ff132648cddc57ff2327d99</pre></td></tr><tr><td data-num="3"></td><td data-command=""></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td data-command="[root@xxx soft] $"></td><td><pre>docker <span class="token function">ps</span> <span class="token comment"># 查看容器是否存在该容器</span></pre></td></tr></table></figure><p>如果容器列表中不存在，则通过查看容器日志进行问题排查：</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx soft] $"></td><td><pre>docker <span class="token function">ps</span> -a <span class="token comment"># 查看容器历史记录</span></pre></td></tr><tr><td data-num="2"></td><td data-command="[root@xxx soft] $"></td><td><pre>docker logs -tf --tail <span class="token number">20</span> d7cd19e650dd7 <span class="token comment"># 查看 20 条日志信息</span></pre></td></tr></table></figure><p>通过日志信息，分析容器启动失败或自动停止的原因（一般是 Dockerfile 文件编写错误或文件权限等问题引起的），在排查问题的过程中，您也许会反复用到以下命令：</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx soft] $"></td><td><pre>docker <span class="token function">ps</span> -a</pre></td></tr><tr><td data-num="2"></td><td data-command="[root@xxx soft] $"></td><td><pre>docker logs -tf --tail <span class="token number">20</span> xxx <span class="token comment"># 查看日志</span></pre></td></tr><tr><td data-num="3"></td><td data-command="[root@xxx soft] $"></td><td><pre>docker <span class="token function">rm</span> xxx</pre></td></tr><tr><td data-num="4"></td><td data-command="[root@xxx soft] $"></td><td><pre>docker rmi -f <span class="token variable"><span class="token variable">$(</span>docker images -aq<span class="token variable">)</span></span> <span class="token comment"># 移除所有镜像</span></pre></td></tr><tr><td data-num="5"></td><td data-command="[root@xxx soft] $"></td><td><pre>docker inspect xxx</pre></td></tr></table></figure></li><li><p>启动成功后，进入容器。</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx soft] $"></td><td><pre>docker <span class="token builtin class-name">exec</span> -it d7cd19e650dd7 /bin/bash</pre></td></tr></table></figure><blockquote><p>由于当前容器已存在其他活跃进程，这里使用 <code>CTRL + P + Q</code> 或 <code>exit</code> 均可退出容器。</p><p>另外，在云服务器环境下，外部网络访问时，需要注意配置安全组规则。</p></blockquote></li><li><p>部署测试文件。</p><p>在 <code>/webapps/test</code> 的挂载目录下创建测试文件：</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx soft] $"></td><td><pre><span class="token builtin class-name">cd</span> /home/Chinmoku/build/tomcat/test</pre></td></tr><tr><td data-num="2"></td><td data-command="[root@xxx test] $"></td><td><pre><span class="token function">mkdir</span> WEB-INF</pre></td></tr><tr><td data-num="3"></td><td data-command="[root@xxx test] $"></td><td><pre><span class="token builtin class-name">cd</span> WEB-INF</pre></td></tr></table></figure><p>创建并编辑 <code>web.xml</code> 文件：</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx WEB-INF] $"></td><td><pre><span class="token function">vim</span> web.xml</pre></td></tr></table></figure><p>写入如下内容：</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>web-app</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://java.sun.com/xml/ns/javaee<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>web</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>WebApp_ID<span class="token punctuation">"</span></span> <span class="token attr-name">version</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2.5<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>display-name</span><span class="token punctuation">></span></span>docker-tomcat<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>display-name</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>welcome-file-list</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>welcome-file</span><span class="token punctuation">></span></span>index.html<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>welcome-file</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>welcome-file-list</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>web-app</span><span class="token punctuation">></span></span></pre></td></tr></table></figure><p>创建并编辑 <code>index.html</code> 文件：</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx WEB-INF] $"></td><td><pre><span class="token function">vim</span> index.html</pre></td></tr></table></figure><p>写入如下内容：</p><figure class="highlight html"><figcaption data-lang="HTML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>docker:::tomcat<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>Docker built tomcat successful!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></pre></td></tr></table></figure></li><li><p>外部浏览器访问。</p></li></ol><h4 id="镜像发布"><a class="anchor" href="#镜像发布">#</a> 镜像发布</h4><details><summary>发布到 Docker Hub</summary><div><ol><li><p>Docker Hub 注册账号。</p></li><li><p>登录。</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker login -u <span class="token punctuation">[</span>用户名<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="2"></td><td data-command=""></td><td><pre>Password: ******</pre></td></tr></table></figure></li><li><p>提交。</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker push <span class="token punctuation">[</span>仓库名<span class="token punctuation">]</span>/<span class="token punctuation">[</span>镜像名<span class="token punctuation">]</span>:<span class="token punctuation">[</span>版本标签<span class="token punctuation">]</span></pre></td></tr></table></figure></li></ol></div></details><details><summary>发布到阿里云</summary><div><p>参考阿里云文档：<span class="exturl" data-url="aHR0cHM6Ly9oZWxwLmFsaXl1bi5jb20vZG9jdW1lbnRfZGV0YWlsLzE0MzMzNi5odG1s">https://help.aliyun.com/document_detail/143336.html</span></p></div></details><h3 id="docker-流程总结"><a class="anchor" href="#docker-流程总结">#</a> Docker 流程总结</h3><p><img data-src="https://img.xfc-exclave.com/2021/08/fe3d92358148e397a84020f11c15d5011628612250.png" alt="Docker流程图"></p><h3 id="docker-网络"><a class="anchor" href="#docker-网络">#</a> Docker 网络</h3><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</p><p>当使用 <code>-P</code> 标记时，Docker 会随机映射一个端口到内部容器开放的网络端口。</p><p><code>-p</code> 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。</p><h4 id="docker0"><a class="anchor" href="#docker0">#</a> Docker0</h4><p>宿主机每启动一个 Docker 容器，就会给容器分配一个 IP 。宿主机只要安装了 docker ，就会安装一个 docker0 网卡进行桥接，这种技术被称为 <code>evth-pair</code> 技术。</p><blockquote><p>veth-pair 是成对出现的虚拟设备接口，它们一端连着协议栈，一端彼此相连，正因为有这个特性，它常常充当着一个桥梁，连接着各种虚拟网络设备，以此构建复杂的虚拟网络结构。</p></blockquote><h5 id="docker-的网络模式"><a class="anchor" href="#docker-的网络模式">#</a> Docker 的网络模式</h5><p>执行如下命令，可查看当前主机 docker 环境的网络模式信息：</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker network <span class="token function">ls</span></pre></td></tr><tr><td data-num="2"></td><td data-command=""></td><td><pre>NETWORK ID     NAME      DRIVER    SCOPE</pre></td></tr><tr><td data-num="3"></td><td data-command=""></td><td><pre>0b517709dd56   bridge    bridge    <span class="token builtin class-name">local</span></pre></td></tr><tr><td data-num="4"></td><td data-command=""></td><td><pre>e49e96b5ebf4   <span class="token function">host</span>      <span class="token function">host</span>      <span class="token builtin class-name">local</span></pre></td></tr><tr><td data-num="5"></td><td data-command=""></td><td><pre>963d10eff9fe   none      null      <span class="token builtin class-name">local</span></pre></td></tr></table></figure><blockquote><p>Docker 网桥是宿主机虚拟出来的，并不是真实存在的网络设备，外部网络是无法寻址到的，这也意味着外部网络无法通过直接 Container-IP 访问到容器。如果容器希望外部访问能够访问到，可以通过映射容器端口到宿主主机（端口映射），即 docker run 创建容器时候通过 -p 或 -P 参数来启用，访问容器的时候就通过 [宿主机 IP]:[容器端口] 访问容器。</p></blockquote><ol><li><p>host 模式</p><p>配置方式： <code>-network=host</code></p><p>如果启动容器的时候使用 host 模式，那么这个容器将不会获得一个独立的 Network Namespace ，而是和宿主机共用一个 Network Namespace 。容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。</p><p>host 模式最大的优势在于网络性能比较好，但是 docker host 上已经使用的端口就不能再用了，因此网络的隔离性不好。</p></li><li><p>container 模式</p><p>配置方式： <code>–net=container:[NAME/ID]</code></p><p>这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace ，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。</p></li><li><p>none 模式</p><p>配置方式： <code>–net=none</code></p><p>使用 none 模式时， Docker 容器拥有自己的 Network Namespace ，但是，并不为 Docker 容器进行任何网络配置。也就是说，这个 Docker 容器没有网卡、IP、路由等信息。需要我们自己为 Docker 容器添加网卡、配置 IP 等。</p><p>这种类型的网络没有办法联网，封闭的网络能很好的保证容器的安全性。</p></li><li><p>bridge 模式</p><p>配置方式： <code>–net=bridge</code> （docker 默认）</p><p>当 Docker 进程启动时，会在主机上创建一个名为 docker0 的虚拟网桥，此主机上启动的 Docker 容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。</p><p>从 docker0 子网中分配一个 IP 给容器使用，并设置 docker0 的 IP 地址为容器的默认网关。在主机上创建一对虚拟网卡 veth-pair 设备，Docker 将 veth-pair 设备的一端放在新创建的容器中，并命名为 eth0 （容器的网卡），另一端放在主机中，以 vethxxx 这样类似的名字命名，并将这个网络设备加入到 docker0 网桥中。可以通过 <code>brctl show</code> 命令查看。</p><blockquote><p>使用 <code>brctl show</code> 命令需要先安装工具包： <code>sudo yum install -y bridge-utils</code> 。</p></blockquote><p>bridge 模式是 docker 的默认网络模式，不写 <code>--net</code> 参数，就是 bridge 模式。使用 <code>docker run -p</code> 时， docker 实际是在 iptables 做了 DNAT 规则，实现端口转发功能。可以使用 <code>iptables -t nat -vnL</code> 查看。</p><p><img data-src="https://img.xfc-exclave.com/2021/08/bdbc4f6e310e8f0dc45dd214999934311629190192.png" alt="Docker网络桥接"></p></li></ol><h4 id="容器互联-link"><a class="anchor" href="#容器互联-link">#</a> 容器互联：--link</h4><p>在不同的 docker 容器之间，通过如下方式使用 <code>ping</code> 命令：</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker <span class="token builtin class-name">exec</span> -it tomcat02 <span class="token function">ping</span> tomcat01 <span class="token comment"># default</span></pre></td></tr><tr><td data-num="2"></td><td data-command=""></td><td><pre><span class="token comment"># 假定 tomcat01 和 tomcat02 在启动时均未指定 --link 参数</span></pre></td></tr></table></figure><p>这时，两个容器之间是无法 ping 通的。</p><p>但当容器启动时，可以指定 <code>--link</code> 参数，即可实现不同容器之间通过容器名进行互联，示例如下：</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command=""></td><td><pre><span class="token comment"># 运行一个 tomcat03 容器并连接到 tomcat02</span></pre></td></tr><tr><td data-num="2"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker run -d -P --name tomcat03 --link tomcat02 tomcat</pre></td></tr><tr><td data-num="3"></td><td data-command=""></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td data-command=""></td><td><pre><span class="token comment"># 再次执行 ping 命令</span></pre></td></tr><tr><td data-num="5"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker <span class="token builtin class-name">exec</span> -it tomcat03 <span class="token function">ping</span> tomcat02 <span class="token comment"># success</span></pre></td></tr><tr><td data-num="6"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker <span class="token builtin class-name">exec</span> -it tomcat02 <span class="token function">ping</span> tomcat03 <span class="token comment"># default</span></pre></td></tr></table></figure><p>通过示例，可以看出使用 <code>--link</code> 参数可以<strong>单向</strong>打通容器之间的网络。</p><p>实际上， <code>--link</code> 参数的本质就是在 <code>/etc/hosts</code> 文件中添加映射。</p><blockquote><p>现在 docker 已经不再推荐使用 --link 来进行容器之间的互联，而是推荐使用自定义网络。</p></blockquote><h4 id="容器互联自定义网络"><a class="anchor" href="#容器互联自定义网络">#</a> 容器互联：自定义网络</h4><p>通过 <code>docker network create</code> 命令即可创建自定义网络。</p><p>当使用 <code>docker run</code> 命令启动容器时，其实该命令默认指定了 <code>--network bridge</code> 参数，该参数即表示所启动的容器将使用名为 <code>bridge</code> 的网络， <code>bridge</code> 是 docker0 默认的网络名称，因此，在创建自定义网络的名称应当避开这个名字。</p><p>在创建一个自定义网络时，需要注意的是， subnet 子网是必须配置，并加上掩码； driver 默认即为 bridge 模式，值不值定都行。 gateway 是配置网关，必填。示例如下：</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker network create --driver bridge --subnet <span class="token number">192.168</span>.0.0/16 --gateway <span class="token number">192.168</span>.0.1 mynet</pre></td></tr></table></figure><p>在这条命令中，我们指定了网段为 192.168.0.0 ，掩码为 16 位（即拥有 255*255 个可用 IP，24 位则只有 255 个可用 IP），指定的网关为 192.168.0.1 ，自定义的网络名称为 mynet 。</p><p>查看自定义网络创建是否成功：</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker network <span class="token function">ls</span></pre></td></tr><tr><td data-num="2"></td><td data-command=""></td><td><pre>NETWORK ID     NAME      DRIVER    SCOPE</pre></td></tr><tr><td data-num="3"></td><td data-command=""></td><td><pre>0b517709dd56   bridge    bridge    <span class="token builtin class-name">local</span></pre></td></tr><tr><td data-num="4"></td><td data-command=""></td><td><pre>e49e96b5ebf4   <span class="token function">host</span>      <span class="token function">host</span>      <span class="token builtin class-name">local</span></pre></td></tr><tr><td data-num="5"></td><td data-command=""></td><td><pre>0df835de9886   mynet     bridge    <span class="token builtin class-name">local</span></pre></td></tr><tr><td data-num="6"></td><td data-command=""></td><td><pre>963d10eff9fe   none      null      <span class="token builtin class-name">local</span></pre></td></tr><tr><td data-num="7"></td><td data-command=""></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker network inspect mynet <span class="token comment"># 查看自定义网络信息</span></pre></td></tr></table></figure><p>使用自定义网络创建容器：</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker run -d -P --name tomcat-net-01 --net mynet tomcat</pre></td></tr><tr><td data-num="2"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker run -d -P --name tomcat-net-02 --net mynet tomcat</pre></td></tr><tr><td data-num="3"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker <span class="token builtin class-name">exec</span> tomcat-net-02 <span class="token function">ping</span> tomcat-net-01 <span class="token comment"># success</span></pre></td></tr><tr><td data-num="4"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker <span class="token builtin class-name">exec</span> tomcat-net-01 <span class="token function">ping</span> tomcat-net-02 <span class="token comment"># success</span></pre></td></tr></table></figure><p><strong>网络连通</strong></p><p>通过上面的操作，基于自定义网络创建的容器之间，已经实现网络互联，但自定义网络与 docker0 默认网络之间仍旧无法联通，我们可以通过如下方式，将 docker0 默认的网络添加到自定义的网络中。</p><figure class="highlight bash"><figcaption data-lang="bash"><span>命令行提示符</span></figcaption><table><tr><td data-num="1"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker run -d -P --name tomcat-01 tomcat <span class="token comment"># -network bridge</span></pre></td></tr><tr><td data-num="2"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker <span class="token builtin class-name">exec</span> tomcat-01 <span class="token function">ping</span> tomcat-net-01 <span class="token comment"># fault</span></pre></td></tr><tr><td data-num="3"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker network connect tomcat01 mynet <span class="token comment"># connect tomcat01 to mynet</span></pre></td></tr><tr><td data-num="4"></td><td data-command="[root@xxx ~] $"></td><td><pre>docker <span class="token builtin class-name">exec</span> tomcat-01 <span class="token function">ping</span> tomcat-net-01 <span class="token comment"># success</span></pre></td></tr></table></figure><h4 id="redis-集群部署"><a class="anchor" href="#redis-集群部署">#</a> Redis 集群部署</h4><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre>docker search redis</pre></td></tr><tr><td data-num="2"></td><td><pre>docker pull redis</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">mkdir</span> redis-cluster-d</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token builtin class-name">cd</span> redis-cluster-d</pre></td></tr></table></figure><p><span class="label danger">❗️TODO</span> 待完善</p><h4 id="springboot-微服务打包-docker"><a class="anchor" href="#springboot-微服务打包-docker">#</a> Springboot 微服务打包 Docker</h4><p><span class="label danger">❗️TODO</span> 待完善</p><h3 id="参考"><a class="anchor" href="#参考">#</a> 参考</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20=">https://docs.docker.com</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMW9nNHkxcTdNNA==">https://www.bilibili.com/video/BV1og4y1q7M4</span></li><li><span class="exturl" data-url="aHR0cHM6Ly95ZWFzeS5naXRib29rLmlvL2RvY2tlcl9wcmFjdGljZS9pbnN0YWxsL2NlbnRvcw==">https://yeasy.gitbook.io/docker_practice/install/centos</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8yMmE3MDMyYmI3YmQ=">https://www.jianshu.com/p/22a7032bb7bd</span></li></ul><div class="tags"><a href="/tags/Linux/" rel="tag"><i class="ic i-tag"></i> Linux</a> <a href="/tags/Docker/" rel="tag"><i class="ic i-tag"></i> Docker</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">編集日</span> <time title="修正日：2021-08-10 21:52:17" itemprop="dateModified" datetime="2021-08-10T21:52:17+08:00">2021-08-10</time> </span><span id="computer-science/java-learning-path/5-framework/docker-tutorial/" class="item leancloud_visitors" data-flag-title="给，你要的 Docker 详细教程" title="閲覧数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">閲覧数</span> <span class="leancloud-visitors-count"></span> <span class="text">回</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 寄付</button><p>*~(￣▽￣)~[お茶]を一杯ください</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="チンモク WeChat 支払う"><p>WeChat 支払う</p></div><div><img data-src="/images/alipay.png" alt="チンモク Alipay"><p>Alipay</p></div><div><img data-src="/images/paypal.png" alt="チンモク PayPal"><p>PayPal</p></div></div></div><div id="copyright"><ul><li class="author"><strong>著者： </strong>チンモク <i class="ic i-at"><em>@</em></i>チンモクのブログ</li><li class="link"><strong>記事へのリンク：</strong> <a href="https://www.chinmoku.cc/computer-science/java-learning-path/5-framework/docker-tutorial/" title="给，你要的 Docker 详细教程">https://www.chinmoku.cc/computer-science/java-learning-path/5-framework/docker-tutorial/</a></li><li class="license"><strong>著作権表示： </strong>このブログ内のすべての記事は、特別な記載がない限り <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> の下のライセンスで保護されています。</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/computer-science/others/blog-without-server/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;img.xfc-exclave.com&#x2F;2021&#x2F;08&#x2F;04&#x2F;06cd6eee9f24c7539eea383aee24b1fc1628011907.webp" title="Hexo - 技术小白搭建个人博客"><span class="type">前の記事</span> <span class="category"><i class="ic i-flag"></i> 建站周边知识</span><h3>Hexo - 技术小白搭建个人博客</h3></a></div><div class="item right"><a href="/computer-science/java-learning-path/2-intermediate/spring-tutorial/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;reference-1301046789.cos.ap-nanjing.myqcloud.com&#x2F;blog-img&#x2F;e749302dc5d54a66b60d8b8a8ed1da65.jpg" title="Spring 教程"><span class="type">次の記事</span> <span class="category"><i class="ic i-flag"></i> 进阶篇</span><h3>Spring 教程</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="見出し"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">Docker 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-%E5%B9%B3%E5%8F%B0"><span class="toc-number">1.1.</span> <span class="toc-text">Docker 平台</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-%E5%8F%AF%E4%BB%A5%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-number">1.2.</span> <span class="toc-text">Docker 可以做什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">Docker 体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#docker-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">Docker 守护进程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#docker-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.3.2.</span> <span class="toc-text">Docker 客户端</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#docker-%E6%B3%A8%E5%86%8C%E8%A1%A8"><span class="toc-number">1.3.3.</span> <span class="toc-text">Docker 注册表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#docker-%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.4.</span> <span class="toc-text">Docker 对象</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E6%8A%80%E6%9C%AF%E6%94%AF%E6%8C%81"><span class="toc-number">1.4.</span> <span class="toc-text">底层技术支持</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-%E5%AE%89%E8%A3%85"><span class="toc-number">2.</span> <span class="toc-text">Docker 安装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%A6%81%E6%B1%82"><span class="toc-number">2.1.</span> <span class="toc-text">系统要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%B8%E8%BD%BD%E6%97%A7%E7%89%88%E6%9C%AC"><span class="toc-number">2.2.</span> <span class="toc-text">卸载旧版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-yum-%E5%AE%89%E8%A3%85"><span class="toc-number">2.3.</span> <span class="toc-text">使用 yum 安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-docker"><span class="toc-number">2.4.</span> <span class="toc-text">安装 Docker</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8-docker"><span class="toc-number">2.5.</span> <span class="toc-text">启动 Docker</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B-docker-%E7%94%A8%E6%88%B7%E7%BB%84"><span class="toc-number">2.6.</span> <span class="toc-text">建立 Docker 用户组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95-docker-%E5%AE%89%E8%A3%85"><span class="toc-number">2.7.</span> <span class="toc-text">测试 Docker 安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F"><span class="toc-number">2.8.</span> <span class="toc-text">配置镜像加速</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%B8%E8%BD%BD-docker"><span class="toc-number">3.</span> <span class="toc-text">卸载 Docker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%8F%8A%E5%8E%9F%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">Docker 启动流程及原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">4.1.</span> <span class="toc-text">Docker 启动流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-vs-%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">4.2.</span> <span class="toc-text">Docker VS 虚拟机</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">5.</span> <span class="toc-text">Docker 常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4"><span class="toc-number">5.1.</span> <span class="toc-text">帮助命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E5%91%BD%E4%BB%A4"><span class="toc-number">5.2.</span> <span class="toc-text">镜像命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">5.3.</span> <span class="toc-text">容器命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7-portainer"><span class="toc-number">5.4.</span> <span class="toc-text">可视化工具 Portainer</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-%E9%95%9C%E5%83%8F%E8%AF%A6%E8%A7%A3"><span class="toc-number">6.</span> <span class="toc-text">Docker 镜像详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E5%92%8C%E5%AE%B9%E5%99%A8"><span class="toc-number">6.1.</span> <span class="toc-text">镜像和容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-%E9%95%9C%E5%83%8F%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86"><span class="toc-number">6.2.</span> <span class="toc-text">Docker 镜像加载原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#unionfs%E8%81%94%E5%90%88%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">6.2.1.</span> <span class="toc-text">UnionFS（联合文件系统）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#docker-%E9%95%9C%E5%83%8F%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86-2"><span class="toc-number">6.2.2.</span> <span class="toc-text">Docker 镜像加载原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E7%9A%84%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">6.2.3.</span> <span class="toc-text">镜像的分层结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E9%95%9C%E5%83%8F"><span class="toc-number">6.2.4.</span> <span class="toc-text">提交镜像</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">7.</span> <span class="toc-text">容器数据卷</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E5%90%8D%E6%8C%82%E8%BD%BD%E4%B8%8E%E5%8C%BF%E5%90%8D%E6%8C%82%E8%BD%BD"><span class="toc-number">7.1.</span> <span class="toc-text">具名挂载与匿名挂载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%AE%B9%E5%99%A8"><span class="toc-number">7.2.</span> <span class="toc-text">数据卷容器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dockerfile"><span class="toc-number">8.</span> <span class="toc-text">DockerFile</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dockerfile-%E6%9E%84%E5%BB%BA%E7%A4%BA%E4%BE%8B"><span class="toc-number">8.1.</span> <span class="toc-text">DockerFile 构建示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dockerfile-%E6%9E%84%E5%BB%BA%E8%AF%B4%E6%98%8E"><span class="toc-number">8.2.</span> <span class="toc-text">DockerFile 构建说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dockerfile-%E6%8C%87%E4%BB%A4"><span class="toc-number">8.3.</span> <span class="toc-text">DockerFile 指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dockerfile-%E6%AD%A5%E9%AA%A4%E6%80%BB%E7%BB%93"><span class="toc-number">8.4.</span> <span class="toc-text">DockerFile 步骤总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%B6%E4%BD%9C-tomcat-%E9%95%9C%E5%83%8F"><span class="toc-number">8.5.</span> <span class="toc-text">制作 Tomcat 镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E5%8F%91%E5%B8%83"><span class="toc-number">8.6.</span> <span class="toc-text">镜像发布</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93"><span class="toc-number">9.</span> <span class="toc-text">Docker 流程总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-%E7%BD%91%E7%BB%9C"><span class="toc-number">10.</span> <span class="toc-text">Docker 网络</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#docker0"><span class="toc-number">10.1.</span> <span class="toc-text">Docker0</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#docker-%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">10.1.1.</span> <span class="toc-text">Docker 的网络模式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94-link"><span class="toc-number">10.2.</span> <span class="toc-text">容器互联：--link</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C"><span class="toc-number">10.3.</span> <span class="toc-text">容器互联：自定义网络</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis-%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2"><span class="toc-number">10.4.</span> <span class="toc-text">Redis 集群部署</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#springboot-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%89%93%E5%8C%85-docker"><span class="toc-number">10.5.</span> <span class="toc-text">Springboot 微服务打包 Docker</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">11.</span> <span class="toc-text">参考</span></a></li></ol></div><div class="related panel pjax" data-title="関連記事"><ul><li class="active"><a href="/computer-science/java-learning-path/5-framework/docker-tutorial/" rel="bookmark" title="给，你要的 Docker 详细教程">给，你要的 Docker 详细教程</a></li></ul></div><div class="overview panel" data-title="概要"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="チンモク" data-src="/images/avatar.jpg"><p class="name" itemprop="name">チンモク</p><div class="description" itemprop="description">本站主要以 Java 开发总结文章为主，也会向技术周边进行适当的扩展。此外，偶尔会更新部分其他学习或感兴趣的内容，如语言学习、文本翻译、文艺创作等。</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">20</span> <span class="name">ポスト</span></a></div><div class="item categories"><a href="/categories/"><span class="count">13</span> <span class="name">カテゴリ</span></a></div><div class="item tags"><a href="/tags/"><span class="count">17</span> <span class="name">タグ</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3hmYy1leGNsYXZl" title="https:&#x2F;&#x2F;github.com&#x2F;xfc-exclave"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;twitter.com&#x2F;yourname"><i class="ic i-twitter"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;yourname"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTExMjg2ODg2Mw==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;112868863"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20vYW1laGltZQ==" title="https:&#x2F;&#x2F;weibo.com&#x2F;amehime"><i class="ic i-weibo"></i></span> <span class="exturl item about" data-url="aHR0cHM6Ly9hYm91dC5tZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;about.me&#x2F;yourname"><i class="ic i-address-card"></i></span> <span class="exturl item email" data-url="bWFpbHRvOnhmY19leGNsYXZlQDE2My5jb20=" title="mailto:xfc_exclave@163.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>ホーム</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>投稿</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>アーカイブ</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>カテゴリ</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>タグ</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-link-circle"></i>リンク</a><ul class="submenu"><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友人帳</a></li><li class="item"><a href="/websites/" rel="section"><i class="ic i-sun"></i>サイト</a></li></ul></li><li class="item"><a href="/plan/" rel="section"><i class="ic i-stars"></i>学習計画</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/computer-science/others/blog-without-server/" rel="prev" title="前の記事"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/computer-science/java-learning-path/2-intermediate/spring-tutorial/" rel="next" title="次の記事"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>ランダムな記事</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="カテゴリ 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java-learning-path/" title="カテゴリ JAVA 学习路线">JAVA 学习路线</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java-learning-path/%E5%9F%BA%E7%A1%80%E7%AF%87/" title="カテゴリ 基础篇">基础篇</a></div><span><a href="/computer-science/java-learning-path/3-advanced/zookeeper-tutorial/" title="Zookeeper 基础教程">Zookeeper 基础教程</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="カテゴリ 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java-learning-path/" title="カテゴリ JAVA 学习路线">JAVA 学习路线</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java-learning-path/%E6%89%A9%E5%B1%95%E7%AF%87/" title="カテゴリ 扩展篇">扩展篇</a></div><span><a href="/computer-science/java-learning-path/3-advanced/elasticsearch-tutorial/" title="Elasticsearch 教程">Elasticsearch 教程</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="カテゴリ 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java-learning-path/" title="カテゴリ JAVA 学习路线">JAVA 学习路线</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java-learning-path/%E6%89%A9%E5%B1%95%E7%AF%87/" title="カテゴリ 扩展篇">扩展篇</a></div><span><a href="/computer-science/java-learning-path/6-extension/quartz-tutorial/" title="Quartz 快速入门及常规使用">Quartz 快速入门及常规使用</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/blog-log/" title="【长期置顶】博客文章更新日志">【长期置顶】博客文章更新日志</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%BB%BA%E7%AB%99%E5%91%A8%E8%BE%B9%E7%9F%A5%E8%AF%86/" title="カテゴリ 建站周边知识">建站周边知识</a></div><span><a href="/computer-science/others/blog-without-server/" title="Hexo - 技术小白搭建个人博客">Hexo - 技术小白搭建个人博客</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="カテゴリ 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/Python%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/" title="カテゴリ Python 入门教程">Python 入门教程</a></div><span><a href="/computer-science/python/django-tutorial/" title="Django 网站全栈开发教程">Django 网站全栈开发教程</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="カテゴリ 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java-learning-path/" title="カテゴリ JAVA 学习路线">JAVA 学习路线</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java-learning-path/%E6%9E%B6%E6%9E%84%E7%AF%87/" title="カテゴリ 架构篇">架构篇</a></div><span><a href="/computer-science/java-learning-path/5-framework/docker-tutorial/" title="给，你要的 Docker 详细教程">给，你要的 Docker 详细教程</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="カテゴリ 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java-learning-path/" title="カテゴリ JAVA 学习路线">JAVA 学习路线</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java-learning-path/%E8%BF%9B%E9%98%B6%E7%AF%87/" title="カテゴリ 进阶篇">进阶篇</a></div><span><a href="/computer-science/java-learning-path/2-intermediate/springcloud-tutorial/" title="SpringCloud 教程（Finchley.RELEASE）">SpringCloud 教程（Finchley.RELEASE）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="カテゴリ 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java-learning-path/" title="カテゴリ JAVA 学习路线">JAVA 学习路线</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java-learning-path/%E5%9F%BA%E7%A1%80%E7%AF%87/" title="カテゴリ 基础篇">基础篇</a></div><span><a href="/computer-science/java-learning-path/1-basic/02-java-concurrency/" title="Java 并发编程知识整理">Java 并发编程知识整理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="カテゴリ 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java-learning-path/" title="カテゴリ JAVA 学习路线">JAVA 学习路线</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java-learning-path/%E8%BF%9B%E9%98%B6%E7%AF%87/" title="カテゴリ 进阶篇">进阶篇</a></div><span><a href="/computer-science/java-learning-path/2-intermediate/spring-tutorial/" title="Spring 教程">Spring 教程</a></span></li></ul></div><div><h2>最近のコメント</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2020 – <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">チンモク @ Chinmoku</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="単語の総数">526k 単語</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="読書の合計時間">7:58</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"computer-science/java-learning-path/5-framework/docker-tutorial/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"検索…",empty:"「 ${query} 」については何も見つかりませんでした",stats:"${time} ms以内に ${hits} 件の結果が見つかりました"},valine:!0,fancybox:!0,copyright:"コピーは成功しました。 <br> 再印刷については、 ％s 契約に従ってください。",ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>